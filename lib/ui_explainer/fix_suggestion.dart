import 'package:flutter/rendering.dart' show BoxConstraints;
import 'constraint_chain_analyzer.dart';
import 'layout_decision_recorder.dart';

/// A categorized fix suggestion for a layout issue.
///
/// Suggestions are generated by analyzing the layout decision,
/// constraint chain, and known widget patterns to provide
/// actionable fixes.
///
/// ## Usage
/// ```dart
/// final suggestions = FixSuggestionEngine.suggest(decision);
/// for (final fix in suggestions) {
///   print('${fix.description} (confidence: ${fix.confidence})');
///   if (fix.codeHint != null) print('  Try: ${fix.codeHint}');
/// }
/// ```
class FixSuggestion {
  /// Short human-readable description of the fix.
  final String description;

  /// Optional code snippet or approach hint.
  final String? codeHint;

  /// Confidence level from 0.0 (guess) to 1.0 (certain).
  final double confidence;

  /// Priority: lower = higher priority. Used for sorting.
  final int priority;

  /// The category of this fix suggestion.
  final FixCategory category;

  const FixSuggestion({
    required this.description,
    this.codeHint,
    this.confidence = 0.5,
    this.priority = 0,
    this.category = FixCategory.general,
  });

  @override
  String toString() => 'FixSuggestion($description, '
      'confidence=$confidence, category=${category.name})';
}

/// Categories for fix suggestions.
enum FixCategory {
  /// Add a wrapping widget (Expanded, Flexible, etc.)
  addWrapper,

  /// Change a property on the existing widget
  changeProperty,

  /// Replace the widget with a different one
  replaceWidget,

  /// Add a scrollable ancestor
  addScrollable,

  /// Constrain dimensions explicitly
  constrainDimensions,

  /// General / uncategorized fix
  general,
}

/// Engine that generates [FixSuggestion]s from layout decisions and
/// constraint chains.
///
/// This is a pure pattern-matching engine — it does not modify the
/// widget tree. It analyzes the constraints and widget types to suggest
/// the most likely fix.
class FixSuggestionEngine {
  /// Generate fix suggestions for a layout decision.
  static List<FixSuggestion> suggest(LayoutDecision decision) {
    if (!decision.overflowed) return const [];

    final suggestions = <FixSuggestion>[];
    final widgetType = decision.widgetType.toLowerCase();
    final constraints = decision.constraintsReceived;
    final size = decision.sizeReported;

    final widthOverflow = size.width > constraints.maxWidth;
    final heightOverflow = size.height > constraints.maxHeight;

    // ── Row/Flex horizontal overflow ──────────────────────────────────────
    if (widthOverflow && _isHorizontalFlex(widgetType)) {
      suggestions.add(const FixSuggestion(
        description: 'Wrap overflowing children in Expanded or Flexible',
        codeHint: 'Row(children: [Expanded(child: Text(...)), ...])',
        confidence: 0.92,
        priority: 0,
        category: FixCategory.addWrapper,
      ));
      suggestions.add(const FixSuggestion(
        description: 'Make the Row horizontally scrollable',
        codeHint:
            'SingleChildScrollView(scrollDirection: Axis.horizontal, child: Row(...))',
        confidence: 0.75,
        priority: 1,
        category: FixCategory.addScrollable,
      ));
    }

    // ── Column/Flex vertical overflow ─────────────────────────────────────
    if (heightOverflow && _isVerticalFlex(widgetType)) {
      suggestions.add(const FixSuggestion(
        description: 'Wrap overflowing children in Expanded or Flexible',
        codeHint: 'Column(children: [Expanded(child: ListView(...)), ...])',
        confidence: 0.92,
        priority: 0,
        category: FixCategory.addWrapper,
      ));
      suggestions.add(const FixSuggestion(
        description: 'Wrap the Column in SingleChildScrollView',
        codeHint: 'SingleChildScrollView(child: Column(...))',
        confidence: 0.75,
        priority: 1,
        category: FixCategory.addScrollable,
      ));
    }

    // ── Text overflow ─────────────────────────────────────────────────────
    if (widthOverflow && _isTextWidget(widgetType)) {
      suggestions.add(const FixSuggestion(
        description: 'Add TextOverflow.ellipsis to truncate text',
        codeHint: "Text('...', overflow: TextOverflow.ellipsis)",
        confidence: 0.88,
        priority: 0,
        category: FixCategory.changeProperty,
      ));
      suggestions.add(const FixSuggestion(
        description: 'Wrap the Text in Flexible inside a Row or Column',
        codeHint: 'Flexible(child: Text(...))',
        confidence: 0.82,
        priority: 1,
        category: FixCategory.addWrapper,
      ));
      suggestions.add(const FixSuggestion(
        description: 'Set maxLines to limit the number of text lines',
        codeHint: "Text('...', maxLines: 2, overflow: TextOverflow.ellipsis)",
        confidence: 0.7,
        priority: 2,
        category: FixCategory.changeProperty,
      ));
    }

    // ── Image overflow ────────────────────────────────────────────────────
    if (_isImageWidget(widgetType)) {
      suggestions.add(const FixSuggestion(
        description: 'Set BoxFit.contain or BoxFit.cover on the Image',
        codeHint: 'Image.network(url, fit: BoxFit.cover)',
        confidence: 0.85,
        priority: 0,
        category: FixCategory.changeProperty,
      ));
      suggestions.add(const FixSuggestion(
        description: 'Constrain the Image with SizedBox or AspectRatio',
        codeHint: 'SizedBox(width: 200, height: 200, child: Image(...))',
        confidence: 0.8,
        priority: 1,
        category: FixCategory.constrainDimensions,
      ));
    }

    // ── ListView inside Column (unbounded height) ────────────────────────
    if (heightOverflow && _isScrollableWidget(widgetType)) {
      suggestions.add(const FixSuggestion(
        description: 'Wrap ListView in Expanded when inside a Column',
        codeHint: 'Column(children: [Expanded(child: ListView(...))])',
        confidence: 0.95,
        priority: 0,
        category: FixCategory.addWrapper,
      ));
      suggestions.add(const FixSuggestion(
        description: 'Set shrinkWrap: true on the ListView',
        codeHint:
            'ListView(shrinkWrap: true, physics: NeverScrollableScrollPhysics())',
        confidence: 0.6,
        priority: 2,
        category: FixCategory.changeProperty,
      ));
    }

    // ── Unbounded constraints ─────────────────────────────────────────────
    // When maxWidth/maxHeight is infinity, size can never exceed it numerically,
    // but an unbounded constraint IS the problem — flag it when overflowed.
    if (constraints.maxWidth == double.infinity) {
      suggestions.add(const FixSuggestion(
        description:
            'The widget received unbounded width — add a width constraint',
        codeHint:
            'ConstrainedBox(constraints: BoxConstraints(maxWidth: 400), child: ...)',
        confidence: 0.7,
        priority: 1,
        category: FixCategory.constrainDimensions,
      ));
    }
    if (constraints.maxHeight == double.infinity) {
      suggestions.add(const FixSuggestion(
        description:
            'The widget received unbounded height — add a height constraint',
        codeHint:
            'ConstrainedBox(constraints: BoxConstraints(maxHeight: 600), child: ...)',
        confidence: 0.7,
        priority: 1,
        category: FixCategory.constrainDimensions,
      ));
    }

    // ── Fallback generic suggestion ───────────────────────────────────────
    if (suggestions.isEmpty) {
      if (widthOverflow) {
        suggestions.add(const FixSuggestion(
          description:
              'Constrain the widget width with SizedBox or ConstrainedBox',
          codeHint:
              'ConstrainedBox(constraints: BoxConstraints(maxWidth: 300), child: ...)',
          confidence: 0.4,
          priority: 3,
          category: FixCategory.constrainDimensions,
        ));
      }
      if (heightOverflow) {
        suggestions.add(const FixSuggestion(
          description: 'Constrain the widget height or wrap in a scrollable',
          codeHint:
              'ConstrainedBox(constraints: BoxConstraints(maxHeight: 400), child: ...)',
          confidence: 0.4,
          priority: 3,
          category: FixCategory.constrainDimensions,
        ));
      }
    }

    // Sort by priority
    suggestions.sort((a, b) => a.priority.compareTo(b.priority));
    return suggestions;
  }

  /// Generate suggestions from a constraint chain analysis.
  ///
  /// This uses the full chain of constraints from root to the overflowing
  /// widget to identify WHERE the constraint became problematic.
  static List<FixSuggestion> suggestFromChain(
    LayoutDecision decision,
    List<ConstraintChainLink> chain,
  ) {
    final suggestions = suggest(decision);

    // Find the link where unbounded constraints were introduced
    for (int i = 0; i < chain.length; i++) {
      final link = chain[i];
      if (link.constraints is BoxConstraints &&
          ((link.constraints as BoxConstraints).maxWidth == double.infinity ||
              (link.constraints as BoxConstraints).maxHeight ==
                  double.infinity)) {
        final widgetName = link.widgetType;
        suggestions.insert(
          0,
          FixSuggestion(
            description: 'Unbounded constraint introduced at $widgetName '
                '(level $i in the chain)',
            codeHint: 'Add constraints to $widgetName or its parent',
            confidence: 0.85,
            priority: 0,
            category: FixCategory.constrainDimensions,
          ),
        );
        break;
      }
    }

    return suggestions;
  }

  // ── Pattern matchers ──────────────────────────────────────────────────

  static bool _isHorizontalFlex(String widgetType) =>
      widgetType.contains('row') || widgetType.contains('flex');

  static bool _isVerticalFlex(String widgetType) =>
      widgetType.contains('column') || widgetType.contains('flex');

  static bool _isTextWidget(String widgetType) =>
      widgetType.contains('text') ||
      widgetType.contains('richtext') ||
      widgetType.contains('paragraph');

  static bool _isImageWidget(String widgetType) =>
      widgetType.contains('image') || widgetType.contains('decoratedbox');

  static bool _isScrollableWidget(String widgetType) =>
      widgetType.contains('listview') ||
      widgetType.contains('gridview') ||
      widgetType.contains('customscrollview');
}
